// Code generated by sqlc. DO NOT EDIT.
// source: movie.sql

package db

import (
	"context"
)

const createNewMovie = `-- name: CreateNewMovie :one
INSERT INTO "Movie"(movie_id, movie_name, image_url, runtime, genre, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, movie_id, movie_name, runtime, genre, status, image_url
`

type CreateNewMovieParams struct {
	MovieID   string `json:"movie_id"`
	MovieName string `json:"movie_name"`
	ImageUrl  string `json:"image_url"`
	Runtime   int32  `json:"runtime"`
	Genre     string `json:"genre"`
	Status    string `json:"status"`
}

func (q *Queries) CreateNewMovie(ctx context.Context, arg CreateNewMovieParams) (Movie, error) {
	row := q.db.QueryRowContext(ctx, createNewMovie,
		arg.MovieID,
		arg.MovieName,
		arg.ImageUrl,
		arg.Runtime,
		arg.Genre,
		arg.Status,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.MovieName,
		&i.Runtime,
		&i.Genre,
		&i.Status,
		&i.ImageUrl,
	)
	return i, err
}

const deleteMovie = `-- name: DeleteMovie :exec
DELETE
FROM "Movie"
WHERE movie_id = $1
`

func (q *Queries) DeleteMovie(ctx context.Context, movieID string) error {
	_, err := q.db.ExecContext(ctx, deleteMovie, movieID)
	return err
}

const getAllMovieAvailable = `-- name: GetAllMovieAvailable :many
SELECT id, movie_id, movie_name, runtime, genre, status, image_url
FROM "Movie"
WHERE status = 'RUNNING'
`

func (q *Queries) GetAllMovieAvailable(ctx context.Context) ([]Movie, error) {
	rows, err := q.db.QueryContext(ctx, getAllMovieAvailable)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Movie{}
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.MovieID,
			&i.MovieName,
			&i.Runtime,
			&i.Genre,
			&i.Status,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieById = `-- name: GetMovieById :one
SELECT id, movie_id, movie_name, runtime, genre, status, image_url
FROM "Movie"
WHERE movie_id = $1
`

func (q *Queries) GetMovieById(ctx context.Context, movieID string) (Movie, error) {
	row := q.db.QueryRowContext(ctx, getMovieById, movieID)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.MovieName,
		&i.Runtime,
		&i.Genre,
		&i.Status,
		&i.ImageUrl,
	)
	return i, err
}

const getMovieSelection = `-- name: GetMovieSelection :many
SELECT DISTINCT M.movie_name, M.movie_id, runtime, genre, status, image_url
FROM "Movie" M
         JOIN "Schedule" S on M.movie_id = S.movie_id
WHERE now() < S.time_end
`

type GetMovieSelectionRow struct {
	MovieName string `json:"movie_name"`
	MovieID   string `json:"movie_id"`
	Runtime   int32  `json:"runtime"`
	Genre     string `json:"genre"`
	Status    string `json:"status"`
	ImageUrl  string `json:"image_url"`
}

func (q *Queries) GetMovieSelection(ctx context.Context) ([]GetMovieSelectionRow, error) {
	rows, err := q.db.QueryContext(ctx, getMovieSelection)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMovieSelectionRow{}
	for rows.Next() {
		var i GetMovieSelectionRow
		if err := rows.Scan(
			&i.MovieName,
			&i.MovieID,
			&i.Runtime,
			&i.Genre,
			&i.Status,
			&i.ImageUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :one
UPDATE "Movie"
SET movie_name=$2,
    runtime=$3,
    genre=$3,
    status=$4,
    image_url=$5
WHERE movie_id = $1
RETURNING id, movie_id, movie_name, runtime, genre, status, image_url
`

type UpdateMovieParams struct {
	MovieID   string `json:"movie_id"`
	MovieName string `json:"movie_name"`
	Runtime   int32  `json:"runtime"`
	Status    string `json:"status"`
	ImageUrl  string `json:"image_url"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg UpdateMovieParams) (Movie, error) {
	row := q.db.QueryRowContext(ctx, updateMovie,
		arg.MovieID,
		arg.MovieName,
		arg.Runtime,
		arg.Status,
		arg.ImageUrl,
	)
	var i Movie
	err := row.Scan(
		&i.ID,
		&i.MovieID,
		&i.MovieName,
		&i.Runtime,
		&i.Genre,
		&i.Status,
		&i.ImageUrl,
	)
	return i, err
}
